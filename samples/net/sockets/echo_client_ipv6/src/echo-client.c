/* echo-client.c - Networking echo client */

/*
 * Copyright (c) 2017 Intel Corporation.
 * Copyright (c) 2018 Nordic Semiconductor ASA.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * The echo-client application is acting as a client that is run in Zephyr OS,
 * and echo-server is run in the host acting as a server. The client will send
 * either unicast or multicast packets to the server which will reply the packet
 * back to the originator.
 *
 * In this sample application we create four threads that start to send data.
 * This might not be what you want to do in your app so caveat emptor.
 */

#include <logging/log.h>
LOG_MODULE_REGISTER(net_echo_client_sample, LOG_LEVEL_DBG);

#include <zephyr.h>
#include <errno.h>
#include <stdio.h>

#include <net/socket.h>
#include <net/tls_credentials.h>
#include <net/net_config.h>

#include "common.h"
#include "ca_certificate.h"

#define APP_BANNER "Run echo client"

#define INVALID_SOCK (-1)

/* Generated by http://www.lipsum.com/
 * 2 paragraphs, 179 words, 1160 bytes of Lorem Ipsum
 */
const char lorem_ipsum[] =
	"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque "
	"sodales lorem lorem, sed congue enim vehicula a. Sed finibus diam sed "
	"odio ultrices pharetra. Nullam dictum arcu ultricies turpis congue, "
	"vel venenatis turpis venenatis. Nam tempus arcu eros, ac congue libero "
	"tristique congue. Proin velit lectus, euismod sit amet quam in, "
	"maximus condimentum urna. Cras vel erat luctus, mattis orci ut, varius "
	"urna. Nam eu lobortis velit."
	"\n"
	"Nullam sit amet diam vel odio sodales cursus vehicula eu arcu. Proin "
	"fringilla, enim nec consectetur mollis, lorem orci interdum nisi, "
	"vitae suscipit nisi mauris eu mi. Proin diam enim, mollis ac rhoncus "
	"vitae, placerat et eros. Suspendisse convallis, ipsum nec rhoncus "
	"aliquam, ex augue ultrices nisl, id aliquet mi diam quis ante. "
	"Pellentesque venenatis ornare ultrices. Quisque et porttitor lectus. "
	"Ut venenatis nunc et urna imperdiet porttitor non laoreet massa. Donec "
	"eleifend eros in mi sagittis egestas. Sed et mi nunc. Nunc vulputate, "
	"mauris non ullamcorper viverra, lorem nulla vulputate diam, et congue "
	"dui velit non erat. Duis interdum leo et ipsum tempor consequat. In "
	"faucibus enim quis purus vulputate nullam."
	"\n";

const int ipsum_len = sizeof(lorem_ipsum) - 1;

struct configs conf = {

	.ipv6 = {
		.proto = "IPv6",
		.udp.sock = INVALID_SOCK,
		.tcp.sock = INVALID_SOCK,
	},
};

struct pollfd fds[2];
int nfds=0;
static short event=0;
// poll timeout in  miliseconds
static int poll_timeout = (1 * 60 * 1000);


extern int send_tcp_data(struct data *data);

static void prepare_fds(void)
{

//	if (conf.ipv6.udp.sock >= 0) {
//		fds[nfds].fd = conf.ipv6.udp.sock;
//		fds[nfds].events = POLLIN;
//		nfds++;
//	}

    if (conf.ipv6.tcp.sock >= 0) {
	      fds[nfds].fd = conf.ipv6.tcp.sock;
		    fds[nfds].events = POLLIN|POLLHUP|POLLOUT|POLLERR;
		    nfds++;
	  }
		event = 0;
}

static void event_off ( short evt )
{
    event &= (short) ~evt;

}

static int wait_event( int timeout)
{
    int ret;
	  /* Wait for event on any socket used. Once event occurs,
	  * we'll check them all.
	  */
	  ret = poll(fds, nfds, timeout);
	  if ( ret < 0 )
		    LOG_ERR("Error in poll:%d", errno);
    else {
		  event |= fds[0].revents;
	    if(fds[0].revents & POLLIN) {
	        LOG_INF("Event IN");
			} else if(fds[0].revents & POLLHUP)
		      LOG_INF("Event HUP");
		  else if(fds[0].revents & POLLOUT) {
			    LOG_INF("Event OUT");
			}
			else if(fds[0].revents & POLLERR)
		      LOG_INF("Event ERR");
	  }
	  return ret;
}

static void wait(void)
{
	/* Wait for event on any socket used. Once event occurs,
	 * we'll check them all.
	 */
	if (poll(fds, nfds, K_FOREVER) < 0)
		LOG_ERR("Error in poll:%d", errno);
  else
	{
		  event |= fds[0].revents;
	    if(fds[0].revents & POLLIN) {
		      LOG_INF("Event IN");
 //         event |= POLLIN;
		  } else if(fds[0].revents & POLLHUP)
		      LOG_INF("Event HUP");
		  else if(fds[0].revents & POLLOUT) {
		      LOG_INF("Event OUT");
					event |= POLLOUT;
			} else if(fds[0].revents & POLLERR) {
		      LOG_INF("Event ERR");
//					event |= POLLERR;
			}
	}

// FIXME: Shutdown not implemented
//		zsock_shutdown(fds[1].fd,ZSOCK_SHUT_RDWR );

}

static void init_app(void)
{
	LOG_INF(APP_BANNER);

#if 0

#if defined(CONFIG_NET_SOCKETS_SOCKOPT_TLS)
	int err = tls_credential_add(CA_CERTIFICATE_TAG,
				    TLS_CREDENTIAL_CA_CERTIFICATE,
				    ca_certificate,
				    sizeof(ca_certificate));
	if (err < 0) {
		LOG_ERR("Failed to register public certificate: %d", err);
	}
#endif

	init_vlan();
#endif
}

void main(void)
{
    int ret;
    u32_t flags=0;

	  init_app();

    flags |= NET_CONFIG_NEED_IPV6;
	  ret = net_config_init("echo",flags, K_SECONDS(20));
    if ( ret == 0)
		    LOG_INF("Net config ok");
		else
		   LOG_ERR("Net config err...");
reconnect:
	  prepare_fds();

		ret = wait_event(1000);
		if ( ret < 0)
    {
		    LOG_ERR("Poll error...");
				while(1);
 		}
    if ( ret == 0)
			LOG_INF( "Config timeout expired");


	  if (IS_ENABLED(CONFIG_NET_TCP)  ) {
		    ret = start_tcp();
		    if (ret < 0) {
			    goto quit;
		    }
	  }

	  while (true) {

		  if (IS_ENABLED(CONFIG_NET_TCP) && (event&POLLIN) ) {
			    event_off(POLLIN);
					ret = process_tcp();
					if (ret < 0) {
					    goto quit;
					}
		  }

			ret = wait_event(5000);
			if ( ret < 0)
    	{
		    	LOG_ERR("Poll error...");
					while(1);
 			}
    	if ( ret == 0)
				LOG_INF( "TCP timeout expired");

	//	  wait_event(5000); e aqui
			if ( event ) {
			    if (event & POLLIN)
              LOG_INF("Got event POLLIN");
					else if ( event & POLLHUP)
					    LOG_INF("Got event POLLHUP");
					else if ( event & POLLOUT)
					    LOG_INF("Got event POLLOUT");
					else if (event & POLLERR)
					    LOG_INF("Got event POLLERR");

			}

	  } // end true

quit:
	  LOG_INF("Stopping...");

	  if (IS_ENABLED(CONFIG_NET_TCP)) {
		  stop_tcp();
	  }
    k_sleep(10000);
	  LOG_INF("Reconnecting...");
	  nfds = 0;
	  goto reconnect;
}
